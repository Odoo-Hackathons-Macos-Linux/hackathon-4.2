<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Three.js Animation Example</title>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
      }
    }
  </script>

  <link href="/css/output.css" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body class="w-full h-screen">
  <div>
    <canvas id="island" class="w-full h-screen"></canvas>
  </div>

  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

  const renderer = new THREE.WebGLRenderer({
    canvas: document.querySelector('#island'),
    antialias: true,
    powerPreference: "high-performance",
    precision: "highp"
  });

  // Set canvas size correctly
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  const scene = new THREE.Scene();
  let camera;
  let playerHouses = []; // Array to hold multiple player houses
  const playersCount = 30; // Set the number of players (player houses)

  let zones = [
    {name: 'fishZone', x: 29, y: 0, z: 24},
    {name: 'huntZone', x: 35, y: 0, z: -30},
    {name: 'fishZone', x: 40, y: 0, z: -26},
    {name: 'securityZone', x: 12, y: 0, z: -26},
    {name: 'woodZone', x: -33, y: 0, z: -20},
    {name: 'fireZone', x: -15, y: 0, z: -15},
    {name: 'fieldZone', x: -12, y: 0, z: -3},
    {name: 'toolsZone', x: -18, y: 0, z: 14},
    {name: 'laboZone', x: -15, y: 0, z: 17},
    {name: 'waterZone', x: -15, y: 0, z: 35},
    {name: 'houseZone', x: 0, y: 0, z: 0},
  ];

  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  const loadGLTFModel = (path) => {
    return new Promise((resolve, reject) => {
      const loader = new GLTFLoader();
      loader.load(path, (gltf) => {
        scene.add(gltf.scene);

        // Create multiple player houses
        for (let i = 0; i < playersCount; i++) {
          let playerHouse = scene.getObjectByName('PlayerHouse');
          playerHouse.visible = true;
          if (playerHouse) {
            playerHouse = playerHouse.clone(); // Clone the model for multiple houses
            playerHouse.position.set(-4, 0, 0);  // Starting position for all houses
            scene.add(playerHouse);
            playerHouses.push(playerHouse);  // Add to the array of player houses
          }
        }

        resolve();
      }, undefined, reject);
    });
  };

  function retrieveListOfCameras() {
    scene.traverse((object) => {
      if (object.isCamera) {
        camera = object;
      }
    });

    if (!camera) {
      console.error('No camera found in the scene!');
      return;
    }

    camera.fov = 39;
    camera.near = 0.1;
    camera.far = 5000;
    camera.updateProjectionMatrix();
  }

  const animationDuration = 1; // Reduced to 1 second for faster movement
  const totalAnimationTime = 10; // Total time in seconds for all players to finish
  const delayBetweenPlayers = (totalAnimationTime - animationDuration) / Math.max(playersCount - 1, 1);

  let elapsedTimes = []; // Array to track elapsed times for each player house
  let returnFlags = []; // Array to track the return state for each player house
  let startTimes = []; // Array to track the start time for each player (delayed start)
  let playerCompleted = []; // Array to track if a player has finished their movement

  function animatePlayer(deltaTime, player, zoneName, index) {
    if (playerCompleted[index]) {
      // Skip the animation if the player has finished their round-trip
      return;
    }

    const currentTime = Date.now();
    if (startTimes[index] && currentTime < startTimes[index]) {
      // Wait until the delay time has passed
      return;
    }

    // Find the zone object by name
    const zone = zones.find(z => z.name === zoneName);

    let targetPosition;
    if (zone && !returnFlags[index]) {
      targetPosition = new THREE.Vector3(zone.x, zone.y, zone.z); // Target position from the zone
    } else {
      targetPosition = new THREE.Vector3(-4, 0, 0); // Return to starting position
    }

    // Increase elapsed time for this player (scaled to slow down animation)
    elapsedTimes[index] = (elapsedTimes[index] || 0) + deltaTime * 0.8; // Increased movement speed

    // After reaching the zone or after a set duration, reverse the direction and go back to (0, 0, 0)
    if (elapsedTimes[index] >= animationDuration * 1000) {
      if (!returnFlags[index]) {
        returnFlags[index] = true; // Change direction to return to starting position
        elapsedTimes[index] = 0; // Reset elapsed time to start returning
      } else {
        elapsedTimes[index] = 0; // Reset elapsed time after returning
        returnFlags[index] = false; // Start again with new zone
        playerCompleted[index] = true; // Mark player as finished after return
      }
    }

    // Calculate the progress of the animation (from 0 to 1)
    const progress = Math.min(elapsedTimes[index] / (animationDuration * 1000), 1);

    // Interpolate position using progress
    player.position.lerpVectors(player.position, targetPosition, progress);

    // Update the player's world matrix after the position change
    player.updateMatrixWorld(true);
  }

  let previousTimestamp = 0;

  function animate(timestamp) {
    const deltaTime = previousTimestamp === 0 ? 0 : (timestamp - previousTimestamp);
    previousTimestamp = timestamp;

    // Animate all player houses with a delayed start
    const zoneNames = ['fishZone', 'fireZone', 'huntZone', 'woodZone', 'securityZone'];
    playerHouses.forEach((playerHouse, index) => {
      const zoneName = zoneNames[index % zoneNames.length]; // Cycle through zones
      // Set the start time for each player with a calculated delay
      if (!startTimes[index]) {
        startTimes[index] = Date.now() + delayBetweenPlayers * 1000 * index; // Delay in milliseconds
      }
      animatePlayer(deltaTime, playerHouse, zoneName, index);
    });

    renderer.render(scene, camera);
    requestAnimationFrame(animate); // Continue the animation loop
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  loadGLTFModel('/blenderModels/scene.gltf')
    .then(() => {
      retrieveListOfCameras();
      requestAnimationFrame(animate); // Start animation loop once everything is ready
    })
    .catch((error) => {
      console.error('Error loading GLTF model:', error);
    });
  </script>
</body>
</html>
