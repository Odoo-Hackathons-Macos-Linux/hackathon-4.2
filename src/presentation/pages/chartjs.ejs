<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Charts</title>
    <link rel="stylesheet" href="/static/style.css">
    <link href="/css/output.css" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/js/chart-assets/chartOptions.js"></script>
    <style>
        .charts-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 50px; /* Add spacing between charts */
        }

        .chart-container {
            position: relative;
            width: 550px;
            height: 280px;
        }

        .legend {
            position: absolute;
            bottom: -25px; /* Position just below the chart */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }

        .legend span {
            font-size: 24px;
            pointer-events: none; /* Make emojis unclickable */
        }

        canvas {
            display: block; /* Ensure canvas is visible */
        }
    </style>
</head>
<body class="bg-black text-center">
    <div class="charts-container">
        <div class="chart-container">
            <canvas id="myChart" width="550" height="280"></canvas>
            <div class="legend">
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="myChart2" width="550" height="280"></canvas>
            <div class="legend">
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
                <span>ðŸ”¥</span>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let chart1, chart2;

        socket.on('connect', () => {
            console.log('Connected with socket ID:', socket.id);
        });

        socket.on("dataInfo", (currentTurn, data) => {
            if (Array.isArray(data) && data.length >= 2) {
                console.log("Received data:", data);
                updateCharts(data);
            } else {
                console.error("Invalid data received:", data);
            }
        });

        function alignEmojis(chart, legendElement) {
            const meta = chart.getDatasetMeta(0);
            const barPositions = meta.data.map(bar => bar.x);
            const emojis = legendElement.querySelectorAll('span');

            if (emojis.length !== barPositions.length) {
                console.error("Number of emojis does not match number of bars.");
                return;
            }

            barPositions.forEach((barX, index) => {
                const emoji = emojis[index];
                emoji.style.position = 'absolute';
                emoji.style.left = `${barX}px`;
                emoji.style.transform = 'translateX(-50%)'; /* Center emoji */
            });
        }

        function getChartOptions() {
            return {
                scales: {
                    x: { display: false },
                    y: { beginAtZero: true, display: false }
                },
                plugins: {
                    legend: { display: false }
                },
                animation: {
                    duration: 1250,
                    easing: 'easeInOutQuad',
                    onComplete: function () {
                        const chartCanvas = this.chart.canvas;
                        const legendElement = chartCanvas.nextElementSibling;
                        alignEmojis(this.chart, legendElement);
                    }
                }
            };
        }

        function updateCharts(globalData) {
            const data1 = globalData[0];
            const data2 = globalData[1];
            const datamin1 = globalData[2];
            const datamin2 = [0, 0, 0, 100];

            if (chart1) {
                chart1.data.datasets[0].data = data1;
                chart1.update();
            } else {
                const ctx1 = document.getElementById('myChart').getContext('2d');
                chart1 = createChart(ctx1, data1, datamin1);
            }

            if (chart2) {
                chart2.data.datasets[0].data = data2;
                chart2.update();
            } else {
                const ctx2 = document.getElementById('myChart2').getContext('2d');
                chart2 = createChart(ctx2, data2, datamin2);
            }
        }

        function createChart(ctx, data, datamin) {
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['0', '1', '2', '3'],
                    datasets: [{
                        label: 'Data',
                        data: data,
                        backgroundColor: (context) => {
                            const chart = context.chart;
                            const { chartArea } = chart;
                            if (!chartArea) return null;

                            return data.map((value, index) => {
                                const dataminValue = datamin[index];
                                return getGradient(chart, value, dataminValue, 0.2);
                            });
                        },
                        borderColor: (context) => {
                            const chart = context.chart;
                            const { chartArea } = chart;
                            if (!chartArea) return null;

                            return data.map((value, index) => {
                                const dataminValue = datamin[index];
                                return getGradient(chart, value, dataminValue, 1);
                            });
                        },
                        borderWidth: 2
                    }]
                },
                options: getChartOptions()
            });
        }

        function getGradient(chart, value, datamin, opacity) {
            const { ctx, chartArea, scales: { y } } = chart;
            if (!chartArea) return `rgba(200, 200, 200, ${opacity})`;
        
            const { top, bottom } = chartArea;
            const valuePixel = y.getPixelForValue(value);
            const dataminPixel = y.getPixelForValue(datamin);
        
            if (!isFinite(valuePixel) || !isFinite(dataminPixel)) {
                console.warn("Non-finite value detected in gradient calculation. Defaulting to neutral color.");
                return `rgba(200, 200, 200, ${opacity})`; // Return a neutral fallback color
            }
        
            const totalHeight = bottom - top;
            const valuePosition = Math.min(1, Math.max(0, (bottom - valuePixel) / totalHeight));
            const dataminPosition = Math.min(1, Math.max(0, (bottom - dataminPixel) / totalHeight));
        
            const gradient = ctx.createLinearGradient(0, bottom, 0, top);
        
            const startColor = { r: 255, g: 49, b: 3 }; // Red
            const endColor = { r: 45, g: 255, b: 14 }; // Green
        
            function getColor(ratio) {
                const r = Math.floor(startColor.r + (endColor.r - startColor.r) * ratio);
                const g = Math.floor(startColor.g + (endColor.g - startColor.g) * ratio);
                const b = Math.floor(startColor.b + (endColor.b - startColor.b) * ratio);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
        
            gradient.addColorStop(0, getColor(0));
            gradient.addColorStop(dataminPosition, getColor(0.5));
            gradient.addColorStop(valuePosition, getColor(1));
        
            return gradient;
        }
    </script>
</body>
</html>
